/**
 *  Copyright (c) 2018, MasterCard International Incorporated and/or its
 *  affiliates. All rights reserved.
 *
 *  The contents of this file may only be used subject to the MasterCard
 *  Mobile Payment SDK for MCBP and/or MasterCard Mobile MPP UI SDK
 *  Materials License.
 *
 *  Please refer to the file LICENSE.TXT for full details.
 *
 *  TO THE EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT
 *  WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NON INFRINGEMENT. TO THE EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 *  MASTERCARD OR ITS AFFILIATES BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 **/

// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from Utils.djinni

#import <Foundation/Foundation.h>
@class ByteArray;
@class ByteArray;


/** Auto-generated Djinni interface for ::mpsdk::utils::Utils_t */
@interface Utils : NSObject

/**
 * 
 * Clear byte array.
 * 
 * @param buffer the buffer
 * 
 */
+ (void)clearBytes:(NSData* _Nullable)buffer;

/**
 * 
 * Clear ByteArray_t.
 * 
 * @param buffer instance of ByteArray_t
 * 
 */
+ (void)clearByteArray:(ByteArray* _Nullable)buffer;

/**
 * 
 * BCD Amount array to string.
 * 
 * @param data   the data
 * @param offset the offset
 * @param length the length
 * @return the string
 * 
 */
+ (NSString* _Nonnull)bcdAmountArrayToString:(NSData* _Nonnull)data
                                      offset:(int32_t)offset
                                      length:(int32_t)length;

/**
 * 
 * Reads an integer from the given byte array starting at the specified
 * array index using big endian byte order.
 * 
 * @return the read integer value.
 * 
 */
+ (int32_t)readInt:(NSData* _Nonnull)data
            offset:(int32_t)offset;

/**
 * 
 * Reads a (signed) short integer from the byte array using big endian byte
 * order.
 * 
 * @param data   the data
 * @param offset the offset
 * @return the short
 * 
 */
+ (int16_t)readShort:(NSData* _Nonnull)data
              offset:(int32_t)offset;

/**
 * 
 * Writes a integer (4B) to the byte array.
 * 
 * @param buffer a byte array.
 * @param offset defines the offset of the integer in the array.
 * @param value  the value to be written.
 * 
 */
+ (void)writeInt:(ByteArray* _Nonnull)buffer
          offset:(int32_t)offset
           value:(int64_t)value;

/**
 * 
 * Returns true if the two given byte arrays have matching content or if
 * they both are null.
 * 
 * @param a       the a
 * @param b       the b
 * @param aOffset defines where to start comparing bytes in the a
 * array.
 * @param bOffset defines where to start comparing bytes in the b
 * array.
 * @param len     defines how many bytes should be compared.
 * @return true, if successful
 * 
 */
+ (BOOL)equalsEx:(NSData* _Nullable)a
               b:(NSData* _Nullable)b
         aOffset:(int32_t)aOffset
         bOffset:(int32_t)bOffset
             len:(int32_t)len;

/**
 * 
 * Returns true if the two given byte arrays are equal in length and in
 * their contents match, or if they both are null.
 * 
 * @param a the a
 * @param b the b
 * @return true, if successful
 * 
 */
+ (BOOL)equals:(NSData* _Nullable)a
             b:(NSData* _Nullable)b;

/**
 * 
 * Perform XOR operation in given data.
 * 
 * @param firstArray   First array
 * @param firstOffset  First offset
 * @param secondArray  Second array
 * @param secondOffset Second offset
 * @param length       Length
 * @return byte array
 * 
 */
+ (NSData* _Nonnull)doXorEx:(NSData* _Nonnull)firstArray
                firstOffset:(int32_t)firstOffset
                secondArray:(NSData* _Nonnull)secondArray
               secondOffset:(int32_t)secondOffset
                     length:(int32_t)length;

/**
 * 
 * Perform XOR operation in given data.
 * 
 * @param firstArray  First array
 * @param secondArray Second array
 * @param length      Length
 * @return byte array
 * 
 */
+ (NSData* _Nonnull)doXor:(ByteArray* _Nonnull)firstArray
              secondArray:(ByteArray* _Nonnull)secondArray
                   length:(int32_t)length;

/**
 * 
 * Convert a long input to a binary byte array
 * 
 * @param value   The long value to be converted to BCD Byte Array
 * @param noBytes The number of bytes into which the result should be stored
 * @return The Binary Byte Array containing the representation of the long
 * 
 */
+ (ByteArray* _Nonnull)longToBinaryByteArray:(int64_t)value
                                                noBytes:(int32_t)noBytes;

/**
 * 
 * Convert a long into a Byte Array encoded with BCD
 * For example, longToBcdByteArray(1023, 6) is coded as 0x000000001023
 * 
 * @param number  The long value to be converted to BCD Byte Array
 * @param noBytes The number of bytes into which the result should be stored
 * @return A Byte Array BCD encoded
 * 
 */
+ (ByteArray* _Nonnull)longToBcdByteArray:(int64_t)number
                                             noBytes:(int32_t)noBytes;

+ (NSData* _Nonnull)longToBcd:(int64_t)num
                         size:(int32_t)size;

/**
 * 
 * Check whether an array is composed of all zeroes elements.
 * 
 * @param data The input data as ByteArray_t
 * @return true if all the elements are 0x00, false otherwise
 * 
 */
+ (BOOL)isByteArrayZero:(ByteArray* _Nonnull)data;

/**
 * 
 * Check whether an array is composed of all zeroes elements.
 * 
 * @param data The input data as byte[]
 * @return true if all the elements are 0x00, false otherwise
 * 
 */
+ (BOOL)isBinaryZero:(NSData* _Nonnull)data;

/**
 * 
 * Copy a sub range of the given array start is included, end is excluded
 * 
 * @param value The byte[] to be parsed
 * @param start The index of the first item to be copied
 * @param end   The index after the last item to be copied
 * @return The copied range
 * 
 */
+ (NSData* _Nonnull)copyArrayRange:(NSData* _Nonnull)value
                             start:(int32_t)start
                               end:(int32_t)end;

/**
 * 
 * Utility function to convert two bytes (e.g. a word) into a char (or integer). We could
 * have used Java libraries (e.g. Integer.valueOf(String...)), however, that would have been
 * limiting from a  security perspective (need to rely on strings
 * 
 */
+ (int16_t)wordToChar:(uint8_t)first
               second:(uint8_t)second;

/**
 * 
 * Pad the PAN to be of even length in case of odd PANs. It is used to pad the remote
 * management PAN information
 * 
 */
+ (NSString* _Nonnull)padPan:(NSString* _Nonnull)inputPan;

/**
 * 
 * Convert a byte BCD encoded value into an integer
 * 
 * @param input The BCD packed byte
 * @return the integer value representing the BCD packed byte
 * 
 */
+ (int32_t)bcdByteToInt:(uint8_t)input;

/**
 * 
 * PAN is initial 10 bytes of digitized card id padded with 'F'
 * Note : Please refer following details for how we parse DC_ID to retrieve PAN
 * The DC_ID (17 bytes) is a unique identifier of a Digitized Card.
 * It is the concatenation of the following information:
 * - Tokenized PAN (10 bytes):The value is left justified and padded with trailing
 * hexadecimal 'F's.
 * - PAN Sequence Number (PSN) (1 byte)
 * - Provisioning Date (6 bytes) : The value is a timestamp equals to YYMMDDHHMMSS
 * Reference : MCBP MPA functional Specification V1
 * 
 * @param digitizedCardId Digitized card identifier
 * @return String last 4 digits of the PAN for the wallet to display
 * 
 */
+ (NSString* _Nonnull)getLastFourDigitOfDevicePan:(NSString* _Nonnull)digitizedCardId;

/**
 * 
 * Retrieve PAN from digitized card id
 * 
 * @param digitizedCardId Digitize card id.
 * @return PAN number form given card id.
 * 
 */
+ (NSString* _Nonnull)retrieveDevicePanFromDigitizedCardId:(NSString* _Nonnull)digitizedCardId;

/**
 * 
 * Create a byte[] with the equivalent value of the input.
 * The input data is copied
 * 
 * @param hexString A Java byte array
 * @return a byte[] that has an equivalent value of the input data
 * 
 */
+ (NSData* _Nonnull)fromHexStringToByteArray:(NSString* _Nullable)hexString;

/**
 * 
 * Convert the Byte Array into a Java String HEX formatted
 * 
 * @return A Java String with the content of the Byte Array encoded in HEX
 * 
 */
+ (NSString* _Nonnull)fromByteArrayToHexString:(NSData* _Nullable)dataBytes;

/**
 * 
 * Encode the input byte array
 * 
 * @param dataBytes input data bytes
 * @return encoded byte array
 * 
 */
+ (NSData* _Nonnull)encodeBase64:(NSData* _Nonnull)dataBytes;

+ (NSString* _Nonnull)encodeBase64ToString:(NSData* _Nonnull)dataBytes;

/**
 * 
 * Decode the input byte array
 * 
 * @param dataBytes input data bytes
 * @return decoded byte array
 * 
 */
+ (NSData* _Nonnull)decodeBase64:(NSData* _Nonnull)dataBytes;

+ (NSData* _Nonnull)decodeBase64FromString:(NSString* _Nonnull)str;

@end
