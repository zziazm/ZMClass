/**
 *  Copyright (c) 2018, MasterCard International Incorporated and/or its
 *  affiliates. All rights reserved.
 *
 *  The contents of this file may only be used subject to the MasterCard
 *  Mobile Payment SDK for MCBP and/or MasterCard Mobile MPP UI SDK
 *  Materials License.
 *
 *  Please refer to the file LICENSE.TXT for full details.
 *
 *  TO THE EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT
 *  WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NON INFRINGEMENT. TO THE EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 *  MASTERCARD OR ITS AFFILIATES BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 **/

// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from NativeCrypto.djinni

#import <Foundation/Foundation.h>


/**
 * Auto-generated Djinni interface for ::mcbp::nativecrypto::NativeCrypto_t
 * 
 */
@interface NativeCrypto : NSObject

+ (void)initializeEngine:(nonnull NSString *)currentLocalDekId
 currentDataStorageDekId:(nonnull NSString *)currentDataStorageDekId
currentDataStorageMacKeyId:(nonnull NSString *)currentDataStorageMacKeyId
       currentRmKekKeyId:(nonnull NSString *)currentRmKekKeyId
      currentWalletDekId:(nonnull NSString *)currentWalletDekId;

+ (nonnull NSData *)protectDataWithLocalDek:(nonnull NSData *)dataToProtect;

+ (nonnull NSData *)protectDataWithRemoteKek:(nonnull NSData *)dataToProtect;

+ (nonnull NSData *)protectWalletData:(nonnull NSData *)dataToProtect;

+ (nonnull NSData *)protectWalletDataWithKey:(nonnull NSString *)walletDataKeyId
                               dataToProtect:(nonnull NSData *)dataToProtect;

+ (nonnull NSData *)protectDataWithDataStorageDek:(nonnull NSData *)dataToProtect;

+ (nonnull NSData *)unprotectDataStorageDekProtectedData:(nonnull NSData *)protectedData;

+ (nonnull NSData *)protectSessionKey:(nonnull NSData *)unprotectedSessionKey;

+ (nonnull NSData *)exchangeDekForLocalDek:(nonnull NSData *)dekProtectedData
                           protectedDekKey:(nonnull NSData *)protectedDekKey;

+ (nonnull NSData *)exchangeIccKekForLocalDek:(nonnull NSData *)dekProtectedIccKek
                                 protectedDek:(nonnull NSData *)protectedDek
                             iccKekProtectedU:(nonnull NSData *)iccKekProtectedU
                             iccKekProtectedP:(nonnull NSData *)iccKekProtectedP
                             iccKekProtectedQ:(nonnull NSData *)iccKekProtectedQ
                            iccKekProtectedDp:(nonnull NSData *)iccKekProtectedDp
                            iccKekProtectedDq:(nonnull NSData *)iccKekProtectedDq;

+ (nonnull NSData *)exchangeRgkForRemoteKek:(nonnull NSData *)protectedRgk
                           rgkProtectedData:(nonnull NSData *)rgkProtectedData;

+ (nonnull NSData *)buildSignedDynamicApplicationData:(nonnull NSData *)ddaHeader
                                           ddaTrailer:(nonnull NSData *)ddaTrailer
                                            dadHeader:(nonnull NSData *)dadHeader
                                      applicationData:(nonnull NSData *)applicationData
                                         protectedIdn:(nonnull NSData *)protectedIdn;

+ (nonnull NSData *)rolloverDataStorageDekProtectedData:(nonnull NSString *)currentDataStorageDekId
                              alternateDataStorageDekId:(nonnull NSString *)alternateDataStorageDekId
                                          protectedData:(nonnull NSData *)protectedData;

+ (nonnull NSData *)rolloverLocalDekProtectedData:(nonnull NSString *)currentLocalDekId
                              alternateLocalDekId:(nonnull NSString *)alternateLocalDekId
                                    protectedData:(nonnull NSData *)protectedData;

+ (nonnull NSData *)rolloverWalletDekProtectedData:(nonnull NSString *)currentWalletDekId
                              alternateWalletDekId:(nonnull NSString *)alternateWalletDekId
                                     protectedData:(nonnull NSData *)protectedData;

+ (nonnull NSData *)rolloverRmKekProtectedData:(nonnull NSString *)currentRmKekId
                              alternateRmKekId:(nonnull NSString *)alternateRmKekId
                                 protectedData:(nonnull NSData *)protectedData;

+ (void)rolloverDataStorageDek;

+ (void)rolloverLocalDek;

+ (void)rolloverRmKekKey;

+ (void)rolloverWalletDek;

+ (void)rolloverDataStorageMacKey;

+ (nonnull NSString *)getCurrentDataStorageDekId;

+ (nonnull NSString *)getAlternateDataStorageDekId;

+ (nonnull NSString *)getCurrentDataStorageMacKeyId;

+ (nonnull NSString *)getAlternateDataStorageMacKeyId;

+ (nonnull NSString *)getCurrentLocalDataDekId;

+ (nonnull NSString *)getAlternateLocalDataDekId;

+ (nonnull NSString *)getCurrentRmKekKeyId;

+ (nonnull NSString *)getAlternateRmKekKeyId;

+ (nonnull NSString *)getCurrentWalletDekId;

+ (nonnull NSString *)getAlternateWalletDekId;

/**
 * 
 * Generate random 16 byte array for use as RGK and return the value protected by the RM_KEK
 * 
 * @return 16 byte RGK protected by RM_KEK
 * 
 */
+ (nonnull NSData *)generateRandomGeneratedKey;

/**
 * 
 * Strips the W_DEK protection on the mobile PIN, applies an algorithm to generate the PIN block
 * and returns the result protected by the RGK.
 * <p/>
 * This is necessary for generating the registration request parameters when registration is
 * performed via the payment app server
 * 
 */
+ (nonnull NSData *)protectPinBlockWithRgk:(nonnull NSData *)protectedRgk
              applicationPaymentInstanceId:(nonnull NSData *)applicationPaymentInstanceId
                                   pinData:(nonnull NSData *)pinData;

/**
 * 
 * Strips the W_DEK protection on the mobile PIN, applies an algorithm to generate the PIN block
 * and returns the result protected by the MDES DEK.
 * <p/>
 * This is necessary for some service requests (e.g. change PIN) which need to have the data
 * protected by the MDES DEK key before it can be sent to the server.
 * 
 */
+ (nonnull NSData *)protectPinBlockWithDek:(nonnull NSData *)protectedDek
              applicationPaymentInstanceId:(nonnull NSData *)applicationPaymentInstanceId
                                   pinData:(nonnull NSData *)pinData;

/**
 * 
 * \brief    Compute the UMD and MD Cryptograms to be used in the Generate AC
 * 
 */
+ (nonnull NSData *)generateAc:(nonnull NSData *)cryptogramInput
                 umdSessionKey:(nonnull NSData *)umdSessionKey
                  mdSessionKey:(nonnull NSData *)mdSessionKey;

/**
 * 
 * \brief    Compute the UMD and MD Cryptograms to be used in the
 * Compute Cryptographic Checksum operation
 * 
 */
+ (nonnull NSData *)computeCc:(nonnull NSData *)cryptogramInput
                umdSessionKey:(nonnull NSData *)umdSessionKey
                 mdSessionKey:(nonnull NSData *)mdSessionKey;

/**
 * 
 * \brief    Compute the UMD and MD Cryptograms to be used in the
 * Compute Cryptographic Checksum operation
 * 
 */
+ (nonnull NSData *)deriveSessionKeyFromSingleUseKey:(nonnull NSData *)singleUseKey
                                           mobilePin:(nonnull NSData *)mobilePin;

/**
 * 
 * Decrypt a notification data message.
 * It first verify that the MAC matches and then decrypt the data.
 * It returns an empty ByteArray if the MAC does not match the received ones
 * 
 */
+ (nonnull NSData *)decryptNotificationData:(nonnull NSData *)responseData
                                     macKey:(nonnull NSData *)macKey
                               transportKey:(nonnull NSData *)transportKey;

/**
 * 
 * Decrypt a CMS Service Response
 * @param service_data   The data as received from the CMS, which is expected
 * to be in the format of COUNTERS | ENC_DATA | MAC
 * @param mac_key        The mobile MAC key
 * @param transport_key  The mobile transport key
 * @param session_code   The session code used to diversify Transport and Mac
 * keys.
 * @return The uncrypted response data
 * 
 */
+ (nonnull NSData *)decryptServiceResponse:(nonnull NSData *)serviceData
                                    macKey:(nonnull NSData *)macKey
                              transportKey:(nonnull NSData *)transportKey
                               sessionCode:(nonnull NSData *)sessionCode;

+ (nonnull NSData *)getLocalDekProtectedIdn:(nonnull NSData *)protectedDekKey
                               protectedIdn:(nonnull NSData *)protectedIdn;

/**
 * 
 * Calculate the Authentication Code as specified in the MCBP MDES CMS-D APIs
 * 
 * @param mobile_keyset_id    The Mobile Key Set Id (as byte array)
 * @param device_finger_print The Device Finger Print
 * @param session_code       The Session Code
 * @return A byte array containing the authentication code
 * 
 */
+ (nonnull NSData *)calculateAuthenticationCode:(nonnull NSData *)mobileKeysetId
                              deviceFingerPrint:(nonnull NSData *)deviceFingerPrint
                                    sessionCode:(nonnull NSData *)sessionCode;

/**
 * 
 * Initializes the ICC RSA key using the provided protected components in concatenated form
 * 
 */
+ (int32_t)initIccKey:(nonnull NSData *)ldekProtectedIccKey;

/**
 * 
 * Signs the RGK with the CMS-D public key.
 * 
 */
+ (nonnull NSData *)createSignedRgk:(nonnull NSData *)protectedRandomGeneratedKey
                          publicKey:(nonnull NSData *)publicKey;

/**
 * 
 * Provides the database component with a way to generate a MAC for a given piece of data using
 * the current DST_MAC
 * 
 */
+ (nonnull NSData *)generateMac:(nonnull NSData *)protectedData;

/**
 * 
 * Provides the database component with a way to generate a MAC for a given piece of data using
 * the specified DST_MAC identified by the provided DST_MAC key Id
 * 
 */
+ (nonnull NSData *)generateMacForKeyId:(nonnull NSData *)protectedData
                               macKeyId:(nonnull NSString *)macKeyId;

/**
 * 
 * Provides the database component with a way to validate that the MAC it has stored for a
 * particular piece of data is in fact valid
 * 
 */
+ (BOOL)isMacValid:(nonnull NSData *)protectedData
         macToTest:(nonnull NSData *)macToTest;

/**
 * 
 * Perform SHA 1 hashing against supplied data
 * 
 */
+ (nonnull NSData *)sha1:(nonnull NSData *)dataToHash;

/**
 * 
 * Perform SHA 256 hashing against supplied data
 * 
 */
+ (nonnull NSData *)sha256:(nonnull NSData *)dataToHash;

@end
